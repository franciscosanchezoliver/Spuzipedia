<!DOCTYPE html>
<html>

<head>
	<title>
		Arquitecturas de ordenador
	</title>
</head>

<body>
	<h1>Índice</h1>
	<ol>
	</ol>

	<h1>Arquitecturas de ordenador</h1>
	<h2>Clasificación</h2>
	<pre style="border: none;">
                   -- Von Neumann
 --  estructura --|
|                  -- Hardvard  
|                             -- CISC
|-- conjunto instrucciones --|-- RISC
|                             -- SISC
|                        -- 1
 -- número de núcleos --|
                         -- +1</pre>

	<h2>Según la <question>estructura</question></h2>
	<ul>
		<li>Arquitectura de <question>Von Neumann</question>: 
			<ul>
				<li><question>CPU</question> (Unidad Central de Proceso)</li>
				<ul>
					<li><question>ALU</question> (Unidad Aritmético Lógica). Con registros del procesador.</li>
					<li><question>UC</question>(Unidad de Control). Con <question>registro de instrucciones y contador de programa</question>.</li>
					<li><question>Memoria</question> para <question>guardar datos e instrucciones</question>.</li>
					<li>Mecanismos de <question>entrada y salida</question>.</li>
					<li>
						Características
						<ul>
							<li>
								La <question>búsqueda de instrucciones</question> y una <question>operación de datos</question> comparten el <question>mismo bus</question> por lo que <question>no pueden hacerse a la vez</question>.
							</li>
							<li><question>La unidad de control indica que operación realizar</question> en cada momento (contador de programa).</li>
						</ul>
					</li>
				</ul>
			</ul>
			<img src="../imagenes/Arquitecturaneumann.jpg" alt="arquitectura_von_neumann">
		</li>
		<li>
			Arquitectura <question>Hardvard</question>: tiene un <question>conjunto de direcciones y buses separados para instrucciones y datos</question>.
		</li>
	</ul>
	<p>
		La arquitectura de <question>Von Neumann</question> es <question>más sencilla</question> la de <question>Hardvard</question>, pero la de <question>Hardvard</question> es <question>más moderna</question>. Ambas son <question>sistemas de programas almacenados</question>, es decir, <question>guardan las instrucciones de programa y</question> los <question>datos en una memoria de lectura y escritura.</question> 
	</p>

	<h2>Según el <question>conjunto de instrucciones</question></h2> 
	<ul>
		<li>Arquitectura <question>CISC</question> (<question>Complex Instruction Set Computer</question>).
			<ul>
				<li>
					Microprocesadores con un <question>conjunto de instrucciones amplio</question>.
				</li>
				<li>
					Son <question>capaces de realizar operaciones complejas</question>.
				</li>
				<li>
					<question>Los operandos de estas operaciones pueden estar en memoria o en registros internos</question>. 
				</li>
				<li>
					Son <question>anteriores a los RISC</question>.
				</li>
			</ul>
		</li>

		<li>
			Arquitectura <question>RISC</question> (<question>Reduced Instruction Set Computer</question>)
			<ul>
				<li>Microprocesadores con <question>instrucciones de tamaño fijo</question>.</li>
				<li><question>Conjunto de instrucciones reducido</question>.</li>
				<li>Realizan <question>operaciones simples</question>.</li>
				<li>A diferencia de CISC <question>solo las instrucciones de carga y almacenamiento acceden a memoria</question>.</li>
				<li><question>Facilitan</question> la <question>segmentación</question> <question>y</question> el <question>paralelismo</question>.</li>
			</ul>
		</li>

		<li>
			Arquitectura <question>SISC</question> (<question>Simple Instruction Set Computer</question>)
			<ul>
				<li><question>Subtipo de RISC</question>.</li>
				<li><question>Orientada al procesamiento paralelo</question>.</li>
				<li>Usa tecnología <a href="https://es.wikipedia.org/wiki/Integraci%C3%B3n_a_muy_gran_escala" target="_blank">VLSI (Very Large Scale Integration)</a>.</li>
			</ul>
		</li>
	</ul>

	<h2>Según el <question>número de núcleos</question></h2>
	<ul>
		<li><question>Un núcleo</question>: el microprocesador tiene <question>1 CPU</question></li>
		<li><question>Varios núcleos</question>: hay <question>varias CPU que leen y ejecutan instrucciones a la vez</question>. Esto aumenta la velocidad de las aplicaciones que estén adaptadas al procesamiento paralelo.</li>
	</ul>

	<h3 id="algoritmos_de_planificacion"><question>Algoritmos de Planificación</question></h3>
	<p>
		Contolan <question>qué procesos se tienen que ejecutar en el procesador</question> en cada momento <question>y el orden</question>. Evitan que un proceso acapare todo el tiempo del procesador.
	</p>

	<p>
		Los <question>3 estados</question> que puede tener un <question>proceso</question> son:
		<ul>
			<li><question>Listo</question>.</li>
			<li><question>Bloqueado</question>.</li>
			<li><question>En ejecución</question>.</li>
		</ul>
	</p>

	<p>
		Algoritmos de planificación:
		<ul>
			<li>
				<question>FIFO</question> o (First In First Out): se <question>encolan los procesos por orden de llegada</question>. El primero en llegar es ejecutado, cuando este termina pasa el siguiente en la lista.
			</li>
			<li>
				<question>Round Robin</question>:
				<ul>
					<li><question>Usa "time-slices"</question> o "quantums". <question>Intervalos de tiempo asignados a cada proceso</question>.</li>
					<li>Cuando un proceso termina con su tiempo, le toca al siguiente proceso en la lista, y este volvería la cola a esperar a que le toque otra vez el "quantum".</li>
					<li><question>Selfish Round Robin</question>: se usan <question>2 colas</question>, una para los <question>procesos nuevos</question> y otra para los <question>procesos antiguos</question>. Se da prioridad a los antiguos.</li>
				</ul>
			</li>
			<li>
				<question>SJF</question> (<question>Shortest Job First</question>): el <question>proceso más corto se ejecuta primero</question>. La desventaja es que los procesos largos pueden quedarse en la cola para siempre si siguen llegando procesos cortos.
			</li>
			<li>
				<question>SRTF</question> (<question>Short Remaining Time First</question>): tiene prioridad al <question>proceso que le quede menos tiempo de ejecución</question>, este será el que coja el procesador. Es decir, si mientras se ejecuta un proceso había otro proceso que estaba en estado bloqueado (por ejemplo esperando que se liberase un recurso) y ahora está en estado "listo" y le queda menos tiempo de ejecución entonces este cogerá el procesador.
			</li>
		</ul>
	</p>


	<script src="../js/testMode.js"></script>
</body>


</html>