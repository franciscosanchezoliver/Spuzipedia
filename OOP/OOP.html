<!DOCTYPE html>
<html>

<head>
	<title>
		OOP
	</title>
</head>

<body>

	<h1>Índice</h1>
	<ol>
		<li> <a href="#oop">OOP</a>
			<ul>
				<li><a href="#intro_oop">Introducción</a></li>
				<li><a href="#dif_con_programacion_estructurada">Diferencia con la programación estructurada</a></li>
				<li><a href="#conceptos_fundamentales">Conceptos fundamentales</a></li>
				<li><a href="#caracteristicas_de_oop">Características de la programación orientada a objetos</a></li>
			</ul>
		</li>
		<li><a href="#uml">UML (Lenguaje de Modelado Unificado)</a>
			<ul>
				<li><a href="#tipos_diagramas_uml_2.5">Tipos de diagramas en UML 2.5</a></li>
				<li><a href="#estructurales">Estructurales</a></li>
				<li><a href="#diagrama_comportamiento">Comportamiento</a></li>
			</ul>
		</li>
	</ol>

	<h1 id="oop">OOP (Programación Orientada a Objetos)</h1>
	<ul>
		<li><question>
			Object Oriented Programming
		</question>.</li>
		<li>Es un <question>
			paradigma de programación
		</question>.</li>
		<li>Los <question>
			objetos manipulan los datos de entrada y devuelven una salida
		</question>.</li>
		<li>Cada <question>
			objeto ofrece una
		funcionalidad</question> especial.</li>
		<li>Podemos <question>
			agrupar
		</question> los <question>
			objetos en bibliotecas o librerías
		</question>.</li>
		<li>La Programación orientada a objetos está basada en varias técnicas (APACHE): 
			<ul>
				Abstracción.
			</ul>
			<ul>
				Polimorfismo.
			</ul>
			<ul>
				Acoplamiento.
			</ul>
			<ul>
				Cohesión.
			</ul>
			<ul>
				Herencia.
			</ul>
			<ul>
				Encapsulamiento.
			</ul>
		</li>
	</ul>

	<h2 id="intro_oop">Introducción</h2>
	<ul>
		<li>Los objetos son entidades que tienen:
			<ul>
				<li>Estado (atributos).</li>
				<li>Comportamiento(métodos). Los objetos tienen mecanismos de interacción llamados métodos. Los métodos permiten la comunicación 
					entre objetos, esta comunicación favorece el cambio de estado en los propios objetos.
				</li>
				<li>Identidad(id) . Identificador del objeto, es una propiedad que lo diferencia del resto. Un objeto tiene toda la información
					necesaria para poder diferenciarla del resto, incluso diferenciarlo entre los objetos de su misma clase. 
				</li>
			</ul>
		</li>
	</ul>

	<h2 id="dif_con_programacion_estructurada">Diferencia con la programación estructurada</h2>
	<p>
		La programación orientada a objetos se diferencia de la programación estructurada en que un objeto tiene tanto métodos como atributos
		mientras que en la programación estructurada se separan los métodos por un lado y los atributos por otro.<br>
		Si hacemos una clase contenedora de información y otra clase contenedora de métodos estaríamos haciendo una programación estructurada 
		camuflada en un lenguaje de OOP. Entonces la programación orientada a objetos se diferencia de la programación estructurada tradicional
		en que los datos y los procedimientos están separados y sin relación, ya que lo único que se busca es el procesamiento de unos datos de 
		entrada para obtener unos datos de salida.<br>
		La programación estructurada anima al programador a pensar primeramente en las funciones o procedimientos, y en segundo lugar en las 
		estructuras de datos que estos procedimientos manejan. En la programación estructurada solo se escriben funciones que procesan datos.
		En la OOP los programadores primero definen objetos para luego pasarle mensajes solicitando que hagan los métodos por sí mismos.
	</p>
	
	<h2 id="conceptos_fundamentales">Conceptos fundamentales</h2>
	<ul>
		<li>Clase: Una clase se puede definir de las propiedades y del comportamiento de un tipo de objeto. La instanciación es la 
			lectura de estas definiciones y la creación de un objeto a partir de ellas. 
		</li>
		<li>Herencia: por ejemplo la herencia de la clase C a la clase D significa que la clase D hereda todos los atributos y todos 
			los métodos de la clase C como si estos atributos y métodos hubiesen sido definidos por la misma clase C.<br>
			La clase D puede usar los atributos y los métodos definidos como públicos en la clase C, los componentes marcados como privados
			también se heredan pero están escondidos al programador y sólo podrán ser accedidos a través de métodos públicos. Si queremos 
			tener atributos o métodos que solo puedan ser accedidos por subclases y no por las demás clases entonces tenemos que marcar los
			componentes como protegidos (protected), de esta forma los componentes marcados como protected serán accesibles por C y por D pero 
			no por las demás clases.  
		</li>
		<li>Objeto: se una instancia de una clase, tiene propiedades (atributos) y comportamiento (métodos). Los métodos reaccionan a eventos.
			Los objetos se pueden corresponder con objetos reales del mundo que nos rodea, o con objetos internos del sistema (programa).</li>
		<li>Método: es un algoritmo asociado a un objeto. La ejecución de dicho algoritmo se dispararia tras recibir un mensaje. Desde el punto
			de vista del comportamiento, los métodos son lo que el objeto puede hacer. Un método puede producir un cambio en las propiedades de 
			dicho objeto (cambio de estado) o también puede producir la generación de un evento con un nuevo mensaje que active otro método 
			de otro objeto.</li>
		<li>Evento: algo que ocurre en el sistema, puede ser una interacción de un usuario con el sistema o un mensaje enviado por un 
			objeto. El sistema manejará el evento enviando el mensaje adecuado al objeto pertinente. También podemos definir evento como la 
			reacción de un objeto, es decir la acción que genera.
		</li>
		<li>Atributo: propiedades de la clase.</li>
		<li>Mensaje: es una comunicación dirigida a un objeto, esta comunciación le ordena al objeto que ejecute uno de sus métodos con 
			ciertos parámetros.
		</li>
		<li>Estado interno: es una variable privada del objeto, y que por tanto solo puede ser accedida con un método del mismo objeto 
			y que se utiliza para indicar situaciones posibles de dicho objeto. El estado interno de una instancia no es visible al programador 
			y solo puede acceder la variable privada con los métodos.
		</li>
		<li>Componentes de un objeto: atributos, métodos e idéntidad.</li>
		<li>Identificador de un objeto: un objeto se representa por medio de una tabla compuesta por sus atributos y por sus métodos.</li>
	</ul>	
	
	<h2 id="caracteristicas_de_oop">Características de la programación orientada a objetos</h2>
	<ul>
		AMOR APACHE
		<li>Abstracción: el proceso de abstracción permite seleccionar las características más importantes dentro de un conjunto. Identificar
			comportamientos comunes para definir nuevas entidades en el mundo real. La abstracción es básica a la hora de análizar y diseñar 
			un sistema basado en objetos, ya que así podemos modelar un conjunto de clases que permiten modelar la realidad o el problema en 
			concreto.
		</li>
		<li>Modularidad: consiste en dividir el sistema en partes más pequeñas. Cada módulo debe ser lo más independiente posible del resto 
			de la aplicacion y de los otros módulos. Estos módulos se pueden compilar por separado, pero tienen conexiones con otros módulos.
		</li>
		<li>Ocultación: cada objeto está aislado del exterior (es un módulo por sí mismo), y cada objeto expone una interfaz que indica 
			como se puede interactuar con el. La ocultación protege a las propiedades de un objeto de que no se puedan modificar por quien no 
			tenga derecho a acceder a ellas, solamente los métodos internos del objeto pueden modificar su estado. Esto nos asegura que otros 
			objetos no puedan interactuar con el otro objeto de forma inesperada, de esta forma eliminamos efectos secundairos y acciones 
			inesperadas.
		</li>
		<li>Recolección de basura: es una técnica realizada por el entorno de los objetos que se encarga de destruir los objetos y desvincular 
			su enlace a memoria, de los objetos que ya no sean referenciados. Esto implica que el programador no tiene que preocuparse por la 
			asignación y liberación de memoria, ya que el entorno se encargará de asignar memoria cuando se cree un nuevo objeto y se liberará la
			memoria cuando nadie esté usando el objeto. 
		</li>
		<li>Abstracción (arriba).</li>
		<li>Polimorfismo: el polimorfismo está muy relacionado con la herencia y los lenguajes fuertemente tipados. Cuando nosotros definimos
			una variable en un lenguaje de tipado fuerte siempre tenemos que indicar el tipo de datos que va a contener esa variable. Por 
			ejemplo en el siguiente caso la variable "miNumero" siempre va a contener un número. Podemos asignarle diferentes valores, pero 
			todos ellos tienen que ser números enteros, si intentamos asignarle un dato diferente a un entero el compilador nos lanzará un 
			error y no nos permitirá compilar el programa. 
			<pre style= "border:solid 1px">
int miNumero;</pre>
			
			Esto también ocurre con los objetos. Si tenemos por ejemplo una clase "Vehículo" que es la clase padre de la cual heredan las 
			clases: "Moto", "Coche" y "Autobús". Si por ejemplo definimos una variable que apunta a un objeto de la clase "Coche", durante toda
			la vida de esa variable deberá apuntar a un objeto de de la clase "Coche", no podemos luego con la misma variable a puntar a un 
			ojeto de la clase "Moto" o a un objeto de la clase "Autobús", esto se debe a la rigidez que dan los lenguajes fuertemente tipados
			(como java).
			Esto sí que se podría hacer en lenguajes débilmente tipados como Javascript o PHP.<br>
			En el siguiente ejemplo se crea una variable del tipo Coche, y está variable a lo largo de su vida puede apuntar a diferentes 
			objetos de la clase "Coche" pero nunca podrá apuntar a objetos de otras clases.
			<pre style="border:solid 1px">
Coche miCoche = new Coche("BMW antiguo");
//la variable miCoche apunta a un objeto de la clase coche
//pero si nos compramos un coche nuevo entonces esta variable podrá apuntar a otro objeto de la clase "Coche"
miCoche = new Coche("BMW nuevo");</pre> 

			Si nosotros intentamos guardar en la variable un objeto de la clase "Moto" entonces nos saltará un error de compilación.
			<pre style ="border: solid 1px">
Coche miCoche = new Moto("Yamaha");</pre>

			Hasta aquí no hemos hablado de polimorfismo si no del sistema de tipos de los lenguajes fuertemente tipados. Por tanto <question>una variable
			siempre apuntará a un objeto del a clase que se indicó en el momento de su declaración</question>. El <question>polimorfismo es la forma
			que hay para "relajar el sistema de tipos" de forma que también nos acepte objetos de las clases hijas o derivadas</question>.
			En el siguiente ejemplo tenemos una variable de la clase "Vehiculo" y esta variable podrá apuntar a un objeto de la clase "Moto", o 
			de la clase "Coche" o de la clase "Autobús" ya que son sus clases hijas. 
			<pre style="border: solid 1px">
//Nuestra variable de tipo Vehiculo primero podrá apuntar a un objeto de la clase Coche
Vehiculo miVehiculo = new Coche();
//Luego la misma variable podrá apuntar a un objeto de la clase Moto
miVehiculo = new Moto();
//Luego la misma variable podrá apuntar a un objeto de la clase Autobus
miVehiculo = new Autobus();</pre>
		</li>
		<li>Acoplamiento: TODO</li>
		<li>Cohesión: TODO</li>
		<li>Herencia: la herencia de la clase C a la clase D es el mecanismo por el cual la clase D hereda todas las propiedades y operaciones
			de la clase C. La clase D podrá utilizar todos los atributos y métodos heredados que estén marcados como públicos en C. Los 
			componentes registrados como privados en la clase C también se heredan pero permanecerán ocultos al programador y solo podrán ser
			accedidos a través de métodos públicos. Si queremos que ciertos componentes seán accesibles por las clases hijas pero no por las 
			demás clases entoncse tenemos que definir las propiedades como protegidas, de está forma serán accesible solamente por las clases 
			hijas de C pero no por las demás clases.
		</li>
		<li>Encapsulación: significa juntar todos los elementos que consideremos que pertenezcan a la misma entidad en el mismo nivel de 
			abstracción, esto permite aumentar la cohesión de los componentes del sistema. Mucha gente confunde la encapsulación con el 
			principio de ocultación porque ambos se utilizan conjuntamente.<br>
			En la programación orientada a objetos llamamos encapsulamiento al ocultamiento del estado, solo podemos acceder a su estado a
			través de métodos. Cada objeto está aislado del exterior (cada objeto será un modulo natural), y una aplicación se reduce a un 
			conjunto de objetos. La encapsulación protege al objeto de que su estado pueda ser modificado por quien no tenga derecho, así 
			eliminamos efectos secundarios e interacciones inesperadas. <br>
			Así el usuario puede obviar como está implementado el objeto y solo se centra en usarlo. También así controlamos que el usuario 
			pueda cambiar el estado del objeto de formas imprevistas e incontroladas.<br>
			Las variables de un objeto forman su núcleo mas interno, los métodos se encontrarían alrededor de este núcleo. Estos métodos 
			esconden al núcleo de los demás objetos. Al empaquetamiento de las variables de un objeto con la protección de sus métodos se le 
			llama encapsulamiento.<br>
			Hay varios niveles de encapsulamiento:
			<ul>
				<li>
					Abierto: el miembro de la clase puede ser accedido desde el exterior de la clase, desde cualquier parte del programa.
				</li>
				<li>
					Protegido: el miembro de la clase puede ser accedido desde la misma clase y sus subclases hijas.
				</li>
				<li>
					Semi cerrado: solo se accesible desde la clase heredada.
				</li>
				<li>
					Cerrado: Solo es accesible desde la clase.
				</li>

			</ul>
		</li>
	</ul>
	
	<h3>Abstracción</h3>
	<h3>Encapsulamiento</h3>
	<h3>Principio de ocultación</h3>
	<h3>Polimorfismo</h3>
	<h3>Herencia</h3>

	<h2 id="uml">UML (Lenguaje de Modelado Unificado)</h2>
	<ul>
		<li>Unified Modeling Language.</li>
		<li>Lenguaje de modelado de sistemas de software.</li>
		<li>Respaldado por OMG(Object Management Group).</li>
		<li>Es un lenguaje gráfico para:
			<ul>
				<li>Documentar</li>
				<li>Definir</li>
				<li>Especificar</li>
				<li>Construir</li>
				<li>Visualizar</li>
			</ul>
		</li>
		<li>
			UML nos da un estándar para poder hacer un plano (modelo) del sistema.
		</li>
		<li>
			Lo utilizamos para definir un sistema, detallar sus artefactos, documentar y construir.
		</li>
		<li>
			Usamos UML para dar soporte a cualquier metodología de desarrollo (como por ejemplo si seguimos RUP (Rational Unified Process)), 
			pero UML no nos obliga a seguir ninguna de las metodologías de desarrollo.
		</li>
		<li>
			UML no es programación, solo se diagrama la realidad. 
		</li>
		<li>
			La programación orientada a objetos es un complemento perfecto para UML. Sin embargo esto no quiere decir que no se pueda usar UML 
			en lenguajes estructurados.
		</li>
		<li>
			UML cuenta con una gran variedad de diagramas, cada uno de ellos muestra un aspecto diferente de lsa entidades representadas.
		</li>
		<li>
			Desde al año 2004, UML es un estándar aprobado por la ISO como "ISO/IEC 19501:2005 Information technology — Open Distributed 
			Processing — Unified Modeling Language (UML) Versión 1.4.2". <br>
			En el año 2012 se actualizó la norma a la última versión (2.4.1) dando lugar a las normas ISO/IEC 19505-1
		</li>
	</ul>

	<h3 id="tipos_diagramas_uml_2.5">Tipos de diagramas en UML 2.5</h3>
	<p>
		Hay principalmente 2 tipos de clases de diagramas: estructurales y de comportamiento. Los de comportamiento representan interacciones.
		Estos diagramas pueden ser clasificados según la siguiente jerarquía:
	</p>
	<ul>
		<li>	
			Estructurales
			<ul>
				<li>Diagrama de clases</li>
				<li>Diagrama de estructura compuesta</li>
				<li>Diagrama de componentes</li>
				<li>Diagrama de despliegue</li>
				<li>Diagrama de objetos</li>
				<li>Diagrama de paquetes</li>
			</ul>
		</li>

		<li>
			Comportamiento
			<ul>
				<li>Diagrama de Actividad</li>
				<li>Diagrama de Casos de Uso</li>
				<li>Diagrama de Máquina de Estado</li>
				<li>Diagrama de Interacción
					<ul>
						<li>Diagrama de Secuencia</li>
						<li>Diagrama de Comunicación</li>
						<li>Diagrama Global de interacción</li>
						<li>Diagrama de Tiempos</li>
					</ul>
				</li>
			</ul>
		</li>
	</ul>
	
	<h3 id="estructurales">Estructurales</h3>
	<p>
		Muestran la estructura estática de los objetos de un sistema.
	</p>
	<ul>
		<li>Diagrama de clases: son el diagrama UML más utilizado. Este es el bloque principal de cualquier solución orientada a objetos.
			Muestran las clases del sistema, y de cada clase sus atributos y métodos. También muestra la relación entre clases del sistema.
			Si el sistema es muy grande con muchas clases relacionadas, las clases se agrupan para formar diagramas de clases. Las diferentes 
			relaciones entre clases se establece con diferentes tipos de flechas. 
		</li>
		<li>Diagrama de componentes: muestra la relación estructural entre los componentes de un sistema. Estos diagramas se utilizan para 
			sistemas complejos dónde hay muchos componentes. Los componentes se comunican entre sí mediante interfaces, y las interfaces se 
			enlazan mediante conectores.
		</li>
		<li>Diagrama de despliegue: muestra el hardware del sistema y el software de ese hardware. Estos diagramas son útiles cuando la  
			solución se despliega en varios equipos, cada equipo con una configuración única.
		</li>
		<li>Diagrama de objetos: son muy parecidos a los diagramas de clases. Al igual que los diagramas de clases también muestran la 
			relación que hay entre los objetos, pero el diagrama de objetos muestran ejemplos del mundo real. Se usa para ver como se verá un 
			sistema en un momento dado, debido a que habrá datos en los objetos cuando el sistema se supone que esté funcionando. Normalmente 
			estos diagramas se utilizan para explicar relaciones complejas entre objetos.
		</li>
		<li>Diagrama de paquetes: como su nombre indica, este diagrama musetra las dependencias entre los diferentes paquetes de un 
			sistema.</li>
		<li>Diagrama de estructura compuesta: se utilizan para mostrar la estructura interna de una clase.</li>
	</ul>

	<h3 id="diagrama_comportamiento">Comportamiento</h3>
	<p>
		Muestran el comportamiento dinámico de los objetos de un sistema.
	</p>
	<ul>
		<li>Diagrama de actividades: representan los flujos de trabajo de forma gráfica. Se utilizan para describir el flujo de trabajo 
			empresarial o el flujo de trabajo operativo de un componente de un sistema.  
		</li>
		<li>
			Diagrama de casos de uso: es el tipo de diagrama UML más conocido. Ofrecen una visión general de los actores implicados en el 
			sistema, las diferentes funciones que necesitan esos actores, y cómo interactúan con las funciones del sistema. Es un buen punto 
			de partida de cualquier discusión del proyecto, ya que podemos identificar los principales actores del involucrados y los 
			principales procesos del sistema. 
		</li>
		<li>
			Diagrama de máquina de estados: son muy parecidos a los diagramas de actividades pero las notaciones y el uso de estos diagramas 
			cambian un poco. También se conocen como diagramas de estado. Se utilizan para describir como se comportan los objetos según el 
			estado que tengan en cada momento, ya que según tenga un estado u otro los mismos objetos pueden comportarse de forma distinta.
		</li>
		<li>
			Diagramas de interacción:
			<ul>
				<li>Diagrama de secuencia: muestra como interactuan los objetos entre sí y el orden en el que se producen estas interacciones.
					Es importante indicar que muestran las interacciones entre objetos pero en un determinado escenario. Los procesos se 
					representan verticalmente y las interacciones se muestran como flechas.
				</li>
				<li>
					Diagramas de comunicación: son parecidos a los diagramas de secuencias pero el foco se hace en los mensajes pasados entre 
					los objetos.
				</li>
				<li>
					Diagrama de tiempos: también llamados diagramas de sincronización. Son muy parecidos a los de secuencia, representan el 
					comportamiento de los objetos en un marco de tiempo determinado. Si en el diagrama hay mas de un objeto podemos usar 
					también este diagrama para mostrar la interacción entre los objetos entre un tiempo determinado.  
				</li>
				<li>
					Diagrama global de interacciones: son muy similares a los diagramas de actividad. Mientras los diagramas de actividad 
					muestran una secuencia de procesos, los diagramas de interacción global muestran una secuencia de diagramas de interacción.
					Por tanto podemos decir que el diagrama global de interacción es un conjunto de diagramas de interacción y el orden en el 
					que suceden. Como hemos visto anteriormente hay 7 tipos de diagramas de interacción y por tanto cualquier de ellos puede 
					ser un nodo en un diagrama global de interacción.
				</li>
			</ul>
		</li>
	</ul>

	<script src="../js/testMode.js"></script>
</body>


</html> 

